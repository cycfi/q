= Units

// <!-- # ![Q-Logo](assets/images/q-logo-small.png) Audio DSP Library -->


:toc: auto


== Value

A representation of a linear value as a concept.

=== Expressions

==== Notation

[cols="1,1"]
|===
|Symbol | Description

| `V`          | Value type

| `v`          | Scalar value.

| `a`, `b`     | Instances of `Value`.

|===


==== Constructors and assignment

[cols="1,1"]
|===
| Expression   |  Semantics

| `V{}`        |  Empty brace initialization. Value initialize a `Value`

| `V()`        |  Default construction.

| `V\{v}`       |  Brace initialization from scalar value `v`.

| `V(v)`       |  Construct a `Value` from scalar value `v`.

| `V\{a}`      |  Copy brace initialization from `Value a`.

| `V(a)`       |  Copy construct from `Value a`.

| `a = b`      |  Assignment. Assign `Value b`, to `Value a`.

|===


==== Comparison

[cols="1,1,1"]
|===
| Expression   | Semantics                                     | Return Type

| `a == b`     | Equality.                                     | `bool`

| `a == v`     | Equality with a scalar.                       | `bool`

| `v == b`     | Equality with a scalar.                       | `bool`

| `a != b`     | Non-Equality.                                 | `bool`

| `a != v`     | Non-Equality with a scalar.                   | `bool`

| `v != b`     | Non-Equality with a scalar.                   | `bool`

| `a < b`      | Less than.                                    | `bool`

| `a < v`      | Less than with a scalar.                      | `bool`

| `v < b`      | Less than with a scalar.                      | `bool`

| `a <= b`     | Less than equal.                              | `bool`

| `a <= v`     | Less than equal with a scalar.                | `bool`

| `v <= b`     | Less than equal with a scalar.                | `bool`

| `a > b`      | Greater than.                                 | `bool`

| `a > v`      | Greater than with a scalar.                   | `bool`

| `v > b`      | Greater than with a scalar.                   | `bool`

| `a >= b`     | Greater than equal.                           | `bool`

| `a >= v`     | Greater than equal with a scalar.             | `bool`

| `v >= b`     | Greater than equal with a scalar.             | `bool`

|===

==== Arithmetic

[cols="1,1,1"]
|===
| Expression   |  Semantics                                    | Return Type

| `+a`         | Positive.                                     | `Value`

| `-a`         | Negative.                                     | `Value`

| `a += b`     | Add assign.                                   | `Value&`

| `a -= b`     | Subtract assign.                              | `Value&`

| `a *= b`     | Multiply assign.                              | `Value&`

| `a /= b`     | Divide assign.                                | `Value&`

| `a + b`      | Addition.                                     | `Value`

| `a + v`      | Addition with a scalar.                       | `Value`

| `v + b`      | Addition with a scalar.                       | `Value`

| `a - b`      | Subtraction.                                  | `Value`

| `a - v`      | Subtraction with a scalar.                    | `Value`

| `v - b`      | Subtraction with a scalar.                    | `Value`

| `a * b`      | Multiplication.                               | `Value`

| `a * v`      | Multiplication with a scalar.                 | `Value`


| `v * b`      | Multiplication with a scalar.                 | `Value`

| `a / b`      | Division.                                     | `Value`

| `a / v`      | Division with a scalar.                       | `Value`

| `v / b`      | Division with a scalar.                       | `Value`

|===

== Value Models

=== frequency

Type safe representation of frequency in Hertz.

```c++
struct frequency : _unspecified_base_type_
{
   using base_type = _unspecified_base_type_;
   using base_type::base_type;

   constexpr explicit            frequency(double val);

   constexpr q::period           period() const;
};

// Free functions
constexpr double as_double(frequency f);
constexpr float as_float(frequency f);
```

==== Expressions

In addition to valid expressions for `Value`, `frequency` allows these
expressions.

==== Notation

[cols="1,1"]
|===
| Symbol    |  Description

| `f`          | Instance of `frequency`.

|===

==== Construction

[cols="1,1"]
|===
| Expression      |  Semantics

| `frequency\{f}` |  Construct a `frequency` given a scalar value, `f`.

|===


==== Conversions

[cols="1,1,1"]
|===
| Expression   |  Semantics                                    | Return Type

| `as_float(f)`   | Convert frequency to a scalar.             | `float`

| `as_double(f)`  | Convert frequency to a scalar.             | `double`

|===


==== Misc

[cols="1,1,1"]
|===
| Expression   |  Semantics                                    | Return Type

| `f.period()`    | Get the period (1/f).                      | `period`        |

|===

=== duration

Type safe representation of duration.

```c++
struct duration : _unspecified_base_type_
{
   constexpr                     duration(double val);

   constexpr explicit operator   double() const;
   constexpr explicit operator   float() const;
};
```

==== Expressions

In addition to valid expressions for Value, `duration` allows these
expressions.

==== Notation

[cols="1,1"]
|===
| Symbol    |  Description

| `d`       | Instance of `duration`

|===

==== Conversions

[cols="1,1"]
|===
| Expression   |  Semantics

| `float(d)`   |  Convert duration to a scalar (float)

| `double(d)`  |  Convert duration to a scalar (double)

|===

=== period

Type safe representation of period (reciprocal of frequency).

```c++
struct period : duration
{
   using duration::duration;

   constexpr                     period(duration d);
   constexpr                     period(frequency f);
};
```

==== Expressions

In addition to valid expressions for Value, `period` allows these
expressions.

==== Notation

[cols="1,1"]
|===
| Symbol    |  Description

| `d`       | Instance of `duration`

| `f`       | Instance of `frequency`

| `p`       | Instance of `period`

|===

==== Construction

[cols="1,1"]
|===
| Expression   | Semantics

| `phase\{d}`  | Construct a phase given a duration

| `phase\{f}`  | Construct a phase given a frequency

|===

==== Conversions

[cols="1,1,1"]
|===
| Expression   |  Semantics                                    | Return Type

| `as_float(f)`   | Convert frequency to a scalar.             | `float`

| `as_double(f)`  | Convert frequency to a scalar.             | `double`

|===

=== phase

phase: The synthesizers use fixed point 1.31 format computations where 31
bits are fractional. phase represents phase values that run from 0 to
4294967295 (0 to 2π) suitable for oscillators.

The turn, also cycle, full circle, revolution, and rotation, is a complete
circular movement or measure (as to return to the same point) with circle or
ellipse. A turn is abbreviated τ, cyc, rev, or rot depending on the
application. The symbol τ can also be used as a mathematical constant to
represent 2π radians.

https://en.wikipedia.org/wiki/Angular_unit[https://en.wikipedia.org/wiki/Angular_unit]

```c++
struct phase : _unspecified_base_type_
{
   using base_type = _unspecified_base_type_;
   using base_type::base_type;

   constexpr static auto one_cyc = int_max<std::uint32_t>();
   constexpr static auto bits = sizeof(std::uint32_t) * 8;

   constexpr explicit            phase(value_type val = 0);
   constexpr explicit            phase(float frac);
   constexpr explicit            phase(double frac);
   constexpr explicit            phase(long double frac);
   constexpr                     phase(frequency freq, float sps);

   constexpr static phase        begin();
   constexpr static phase        end();
   constexpr static phase        middle();
};

// Free functions
constexpr double  as_double(phase d);
constexpr float   as_float(phase d);
```

==== Expressions

In addition to valid expressions for Value, `phase` allows these
expressions.

==== Notation

[cols="1,1"]
|===
| Symbol       | Description

| `f`          | A `double` or `float`

| `freq`       | Instance of `frequency`

| `sps`        | Scalar value representing samples per second

| `p`          | Instance of `phase`

|===

==== Construction

[cols="1,1"]
|===
| Expression         | Semantics

| `phase\{f}`        | Construct a phase given the a fractional number from 0.0 to 1.0 (0 to 2π)

| `phase{freq, sps}` | Construct a phase given the frequency and samples per second (`sps`)

|===

==== Conversions

[cols="1,1,1"]
|===
| Expression      | Semantics                                  | Return Type

| `as_float(f)`   | Convert phase to a scalar from 0.0 to 1.0. | `float`

| `as_double(f)`  | Convert phase to a scala from 0.0 to 1.0r. | `double`

|===

==== Min and Max

[cols="1,1,1"]
|===
| Expression      | Semantics                                           | Return Type

| phase::begin()  | Get the minimum phase representing 0 degrees        | `phase`

| phase::end()    | Get the maximum phase representing 360 degrees (2π) | `phase`

| phase::middle() | Get the phase representing 180 degrees (π)          | `phase`

|===


=== basic_interval

== NonLinearValue

A representation of a non-linear scalar value as a concept. These values, unlike linear values, have restricted operations. Non-linear scalar values do not permit comparison with bare scalars (such as `float`), nor do they permit addition and subtraction with bare scalars.

=== Expressions

==== Notation

[cols="1,1"]
|===
|Symbol        | Description

| `V`          | NonLinearValue type

| `v`          | Scalar value.

| `a`, `b`     | Instance of `NonLinearValue`

|===

==== Constructors and assignment

[cols="1,1"]
|===
| Expression   |  Semantics

| `V{}`        |  Empty brace initialization. Value initialize a `Value`.

| `V()`        |  Default construction.

| `V\{v}`      |  Brace initialization from scalar value `v`.

| `V(v)`       |  Construct a `Value` from scalar value `v`.

| `V\{a}`      |  Copy brace initialization from `Value a`.

| `V(a)`       |  Copy construct from `Value a`.

| `a = b`      |  Assignment. Assign `Value b`, to `Value a`.

|===

==== Comparison

[cols="1,1,1"]
|===
| Expression   |  Semantics                                    | Return Type
| `a == b`     | Equality.                                     | `bool`

| `a != b`     | Non-Equality.                                 | `bool`

| `a < b`      | Less than.                                    | `bool`

| `a <= b`     | Less than equal.                              | `bool`

| `a > b`      | Greater than.                                 | `bool`

| `a >= b`     | Greater than equal.                           | `bool`

|===

==== Arithmetic

[cols="1,1,1"]
|===
| Expression   |  Semantics                                    | Return Type

| `+a`         | Positive.                                     | `Value`

| `-a`         | Negative.                                     | `Value`

| `a += b`     | Add assign.                                   | `Value&`

| `a -= b`     | Subtract assign.                              | `Value&`

| `a *= b`     | Multiply assign.                              | `Value&`

| `a /= b`     | Divide assign.                                | `Value&`

| `a + b`      | Addition.                                     | `Value`

| `a - b`      | Subtraction.                                  | `Value`

| `a * b`      | Multiplication.                               | `Value`

| `a * v`      | Multiplication with a scalar.                 | `Value`

| `v * b`      | Multiplication with a scalar.                 | `Value`

| `a / b`      | Division.                                     | `Value`

| `a / v`      | Division with a scalar.                       | `Value`

|===

== NonLinearValue Models

=== decibel

Decibel is non-linear and operates on the logarithmic domain. The `decibel` class is perfectly suitable for dynamics processing (e.g. compressors and limiters and envelopes). Q provides fast `decibel` computations using fast math functions and lookup tables for converting to and from scalars.

```c++
struct decibel
{
   constexpr            decibel();
   explicit             decibel(double val);

   constexpr decibel    operator+() const;
   constexpr decibel    operator-() const;

   constexpr decibel&   operator+=(decibel b);
   constexpr decibel&   operator-=(decibel b);
   constexpr decibel&   operator*=(decibel b);
   constexpr decibel&   operator/=(decibel b);

   double rep = 0.0f;
};

// Free functions
constexpr double  as_double(decibel db);
constexpr float   as_float(decibel db);

constexpr decibel operator-(decibel a, decibel b);
constexpr decibel operator+(decibel a, decibel b);

constexpr decibel operator*(decibel a, decibel b);
constexpr decibel operator*(decibel a, double b);
constexpr decibel operator*(decibel a, float b);
constexpr decibel operator*(decibel a, int b);
constexpr decibel operator*(double a, decibel b);
constexpr decibel operator*(float a, decibel b);
constexpr decibel operator*(int a, decibel b);

constexpr decibel operator/(decibel a, decibel b);
constexpr decibel operator/(decibel a, double b);
constexpr decibel operator/(decibel a, float b);
constexpr decibel operator/(decibel a, int b);

constexpr bool    operator==(decibel a, decibel b);
constexpr bool    operator!=(decibel a, decibel b);
constexpr bool    operator<(decibel a, decibel b);
constexpr bool    operator<=(decibel a, decibel b);
constexpr bool    operator>(decibel a, decibel b);
constexpr bool    operator>=(decibel a, decibel b);
```

==== Expressions

In addition to valid expressions for `NonLinearValue`, `decibel` allows these expressions.

==== Notation

[cols="1,1"]
|===
| Symbol       |  Description

| `a`          | Instance of `decibel`          |

|===

==== Conversions

[cols="1,1,1"]
|===
| Expression      |  Semantics                              | Return Type

| `as_float(f)`   | Convert decibel to a scalar.            | `float`

| `as_double(f)`  | Convert decibel to a scalar.            | `double`

|===






